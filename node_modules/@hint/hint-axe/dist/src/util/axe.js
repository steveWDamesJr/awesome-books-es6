"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const utils_fs_1 = require("@hint/utils-fs");
const utils_types_1 = require("@hint/utils-types");
const i18n_import_1 = require("../i18n.import");
const axeCorePromise = utils_fs_1.readFileAsync(require.resolve('axe-core'));
const registrationMap = new Map();
const getElement = (context, node) => {
    var _a;
    let selector = node.target[0];
    if (Array.isArray(selector)) {
        selector = selector[0];
    }
    return (_a = context.pageDOM) === null || _a === void 0 ? void 0 : _a.querySelector(selector);
};
const hasCheckData = (result) => {
    return !!result.data;
};
const toCheckMessage = (result) => {
    return result.message;
};
const getSummary = (node) => {
    const summary = [...node.all, ...node.any, ...node.none]
        .filter(hasCheckData)
        .map(toCheckMessage)
        .join(' ');
    return summary;
};
const queueRegistration = (registration, map) => {
    const engineKey = registration.context.engineKey;
    const resource = registration.event.resource;
    const registrationsByResource = map.get(engineKey) || new Map();
    const registrations = registrationsByResource.get(resource) || [];
    registrations.push(registration);
    registrationsByResource.set(resource, registrations);
    map.set(engineKey, registrationsByResource);
};
const useRegistrations = (engineKey, resource, map) => {
    const registrationsByResource = map.get(engineKey);
    if (!registrationsByResource) {
        return null;
    }
    const registrations = registrationsByResource.get(resource);
    if (!registrations) {
        return null;
    }
    registrationsByResource.delete(resource);
    if (!registrationsByResource.size) {
        map.delete(engineKey);
    }
    return registrations;
};
const toSeverity = (impact) => {
    if (impact === 'minor') {
        return utils_types_1.Severity.hint;
    }
    if (impact === 'moderate' || impact === 'serious') {
        return utils_types_1.Severity.warning;
    }
    if (impact === 'critical') {
        return utils_types_1.Severity.error;
    }
    return utils_types_1.Severity.warning;
};
const withQuotes = (ruleId) => {
    return `'${ruleId}'`;
};
const run = async (context, event, rules) => {
    const axeCoreSource = await axeCorePromise;
    const { document, resource } = event;
    try {
        const target = document.isFragment ?
            'document.body' :
            'document';
        return await context.evaluate(`(function() {
            ${axeCoreSource}
            var target = ${target};
            return window.axe.run(target, {
                runOnly: {
                    type: 'rule',
                    values: [${rules.map(withQuotes).join(',')}]
                }
            });
        })()`);
    }
    catch (e) {
        let message;
        if (e.message.includes('evaluation exceeded')) {
            message = i18n_import_1.getMessage('notFastEnough', context.language);
        }
        else {
            message = i18n_import_1.getMessage('errorExecuting', context.language, e.message);
        }
        message = i18n_import_1.getMessage('tryAgainLater', context.language, message);
        context.report(resource, message, { severity: utils_types_1.Severity.warning });
        return null;
    }
};
const normalizeOptions = (options) => {
    if (Array.isArray(options)) {
        const normalizedOptions = options.reduce((newOptions, axeRuleId) => {
            newOptions[axeRuleId] = 'default';
            return newOptions;
        }, {});
        return normalizedOptions;
    }
    return options || {};
};
const register = (context, rules, disabled) => {
    const options = normalizeOptions(context.hintOptions);
    const { engineKey } = context;
    const enabledRules = rules.filter((rule) => {
        if (options[rule]) {
            return options[rule] !== 'off';
        }
        return !disabled.includes(rule);
    });
    context.on('can-evaluate::script', (event) => {
        queueRegistration({ context, enabledRules, event, options }, registrationMap);
    });
    context.on('scan::end', async ({ resource }) => {
        const registrations = useRegistrations(engineKey, resource, registrationMap);
        if (!registrations) {
            return;
        }
        let document;
        const ruleToRegistration = registrations.reduce((map, registration) => {
            document = document || registration.event.document;
            registration.enabledRules.forEach((rule) => {
                map.set(rule, registration);
            });
            return map;
        }, new Map());
        const rules = Array.from(ruleToRegistration.keys());
        const result = await run(context, { document, resource }, rules);
        if (!result || !Array.isArray(result.violations)) {
            throw new Error(`Unable to parse axe results ${result}`);
        }
        for (const violation of result.violations) {
            for (const node of violation.nodes) {
                const summary = getSummary(node);
                const message = summary ? `${violation.help}: ${summary}` : violation.help;
                const registration = ruleToRegistration.get(violation.id);
                const element = getElement(context, node);
                const severity = utils_types_1.Severity[registration.options[violation.id]] === utils_types_1.Severity.default ?
                    toSeverity(violation.impact) :
                    utils_types_1.Severity[registration.options[violation.id]];
                registration.context.report(resource, message, {
                    documentation: [{
                            link: violation.helpUrl,
                            text: i18n_import_1.getMessage('learnMore', context.language)
                        }],
                    element,
                    severity
                });
            }
        }
    });
};
exports.register = register;
