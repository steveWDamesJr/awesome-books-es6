"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ava_1 = require("ava");
const sinon = require("sinon");
const proxyquire = require("proxyquire");
const test = ava_1.default;
const asUri = { getAsUri() { } };
const initContext = (t) => {
    t.context.loadJSONFileModule = () => {
        return null;
    };
    t.context.asPathString = () => {
        return '';
    };
    t.context.path = {
        dirname() {
            return '';
        },
        resolve() {
            return '';
        }
    };
    t.context.sandbox = sinon.createSandbox();
};
const loadScript = (context) => {
    const script = proxyquire('../src/final-config', {
        '@hint/utils-fs': { loadJSONFile: context.loadJSONFileModule },
        '@hint/utils-network': {
            asPathString: context.asPathString,
            asUri
        },
        path: context.path
    });
    return script.finalConfig;
};
test.beforeEach(initContext);
test.afterEach.always((t) => {
    t.context.sandbox.restore();
});
test(`If config doesn't have an extends property, it should return the same object`, (t) => {
    const finalConfig = loadScript(t.context);
    const config = { extends: '' };
    const result = finalConfig(config, 'resource');
    t.true(config === result);
});
test('If there is a circular reference, it should return an instance of an Error', (t) => {
    const sandbox = t.context.sandbox;
    sandbox.stub(t.context, 'asPathString').returns('circularReference');
    sandbox.stub(t.context.path, 'resolve').returns('circularReference');
    const finalConfig = loadScript(t.context);
    const config = { extends: 'circularReference' };
    const result = finalConfig(config, 'circularReference');
    t.true(result instanceof Error);
    t.is(result.message, 'Circular reference found in file circularReference');
});
test('If one of the extended files is no a valid JSON, it should return an instance of an Error', (t) => {
    const sandbox = t.context.sandbox;
    sandbox.stub(t.context, 'asPathString').returns('valid-with-invalid-extends');
    sandbox.stub(t.context.path, 'resolve').returns('invalid-extends');
    sandbox.stub(t.context, 'loadJSONFileModule').throws(new Error('InvalidJSON'));
    const finalConfig = loadScript(t.context);
    const config = { extends: 'invalid-extends' };
    const result = finalConfig(config, 'valid-with-invalid-extends');
    t.true(result instanceof Error);
});
test('If everything is ok, it should merge all the extended configurations', (t) => {
    const sandbox = t.context.sandbox;
    sandbox.stub(t.context, 'asPathString').returns('valid-with-extends');
    sandbox.stub(t.context.path, 'resolve')
        .onFirstCall()
        .returns('valid-extends')
        .onSecondCall()
        .returns('valid-extends-2');
    const miscStub = sandbox.stub(t.context, 'loadJSONFileModule')
        .onFirstCall()
        .returns({
        extends: 'valid-extends-2',
        name: 'valid-extends'
    })
        .onSecondCall()
        .returns({
        extends: null,
        name: 'valid-extends-2'
    });
    const finalConfig = loadScript(t.context);
    const config = {
        extends: 'valid-extends',
        name: 'valid'
    };
    const result = finalConfig(config, 'valid-with-extends');
    t.true(miscStub.calledTwice);
    t.is(result && result.name, 'valid');
});
